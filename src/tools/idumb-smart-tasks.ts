/**
 * OpenCode Smart Task Integration
 * 
 * Creates smart delegation tasks that are:
 * 1. Visible in OpenCode TUI
 * 2. Parseable by AI as structured data  
 * 3. Organized and managed by ALL agents
 * 4. Exportable to memory for reasoning and planning
 */

import { tool } from "@opencode-ai/plugin";
import { existsSync, readFileSync, writeFileSync, mkdirSync } from "fs";
import { join } from "path";

// Smart Task Interface - compatible with OpenCode's task system
interface SmartTask {
    id: string;
    content: string;  // What appears in TUI
    description: string;  // Detailed explanation
    status: "pending" | "in_progress" | "completed" | "failed";
    priority: "high" | "medium" | "low";
    tags: string[];  // For filtering and categorization
    metadata: {
        component?: string;
        researchType?: string;
        focusAreas?: string[];
        expectedOutputs?: string[];
        agentType?: string;
        phase?: string;
        autoGenerated: boolean;
        groupName: string;
        [key: string]: any;
    };
}

// Task Group for organization
interface TaskGroup {
    groupName: string;
    agentType: string;
    researchContext?: {
        researchType: string;
        focusAreas: string[];
        expectedOutputs: string[];
        confidenceRequirements: string;
    };
    tasks: SmartTask[];
    createdAt: string;
}

// Main tool for creating smart tasks visible in OpenCode
export const createSmartTasks = tool({
    description: "Create smart delegation tasks that integrate with OpenCode's native task system. Tasks are visible in TUI, parseable by AI, and organized for agent reasoning.",
    args: {
        agentType: tool.schema.string().describe("Agent type (project-researcher, phase-researcher, codebase-mapper, etc.)"),
        phase: tool.schema.string().describe("Current project phase"),
        context: tool.schema.object({}).optional().describe("Additional context for task generation"),
        autoGenerate: tool.schema.boolean().optional().describe("Automatically generate relevant tasks (recommended)")
    },
    async execute(args, context) {
        // Auto-generate tasks based on agent type
        const tasks = args.autoGenerate !== false ? 
            generateAgentTasks(args.agentType, args.phase, args.context || {}) : [];
        
        // Create task group
        const taskGroup: TaskGroup = {
            groupName: `smart-delegation-${args.agentType}-${Date.now()}`,
            agentType: args.agentType,
            researchContext: buildResearchContext(args.agentType),
            tasks,
            createdAt: new Date().toISOString()
        };
        
        // Save in OpenCode-compatible format
        const taskDir = join(context.directory, ".idumb", "brain", "smart-tasks");
        if (!existsSync(taskDir)) {
            mkdirSync(taskDir, { recursive: true });
        }
        
        const taskFile = join(taskDir, `${taskGroup.groupName}.json`);
        writeFileSync(taskFile, JSON.stringify(taskGroup, null, 2));
        
        // Return format that OpenCode can parse and display
        return JSON.stringify({
            status: "tasks_created",
            groupName: taskGroup.groupName,
            taskCount: tasks.length,
            tasks: tasks.map(t => ({
                id: t.id,
                content: t.content,
                status: t.status,
                priority: t.priority,
                tags: t.tags
            })),
            message: `${tasks.length} smart tasks created and visible in OpenCode TUI`
        }, null, 2);
    }
});

// Tool for updating task status
export const updateSmartTask = tool({
    description: "Update smart task status and sync with OpenCode's task system",
    args: {
        taskId: tool.schema.string().describe("Task ID to update"),
        status: tool.schema.string().describe("New status: pending, in_progress, completed, failed"),
        notes: tool.schema.string().optional().describe("Completion notes or results")
    },
    async execute(args, context) {
        const updated = await findAndUpdateTask(args.taskId, args.status, args.notes, context.directory);
        
        if (!updated) {
            return JSON.stringify({ status: "error", message: `Task not found: ${args.taskId}` });
        }
        
        return JSON.stringify({
            status: "updated",
            taskId: args.taskId,
            newStatus: args.status,
            notes: args.notes || "Status updated"
        }, null, 2);
    }
});

// Tool for listing tasks with OpenCode integration
export const listSmartTasks = tool({
    description: "List smart tasks with OpenCode integration status and parsing information",
    args: {
        agentType: tool.schema.string().optional().describe("Filter by agent type"),
        status: tool.schema.string().optional().describe("Filter by status"),
        includeParsed: tool.schema.boolean().optional().describe("Include AI-parseable format")
    },
    async execute(args, context) {
        const allTasks = await getAllTasks(context.directory);
        let filteredTasks = allTasks;
        
        if (args.agentType) {
            filteredTasks = filteredTasks.filter(t => 
                t.metadata.agentType === args.agentType
            );
        }
        
        if (args.status) {
            filteredTasks = filteredTasks.filter(t => t.status === args.status);
        }
        
        const result: any = {
            totalTasks: filteredTasks.length,
            tasks: filteredTasks.map(t => ({
                id: t.id,
                content: t.content,
                status: t.status,
                priority: t.priority,
                agentType: t.metadata.agentType,
                groupName: t.metadata.groupName
            }))
        };
        
        if (args.includeParsed) {
            result.parsedFormat = filteredTasks.map(t => ({
                task_id: t.id,
                action_required: t.content,
                context: t.metadata.researchType,
                dependencies: [], // Would be populated with actual dependencies
                reasoning_basis: `Generated for ${t.metadata.agentType} in ${t.metadata.phase} phase`
            }));
        }
        
        return JSON.stringify(result, null, 2);
    }
});

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function generateAgentTasks(agentType: string, phase: string, context: any): SmartTask[] {
    const tasks: SmartTask[] = [];
    const baseTags = [agentType, phase];
    const groupName = `smart-delegation-${agentType}-${Date.now()}`;
    
    // Research agent tasks
    if (agentType.includes('research')) {
        tasks.push({
            id: `task-context-${Date.now()}`,
            content: "[CONTEXT_INJECTION] Analyze and prepare research context",
            description: "Automatically analyze project domain and prepare relevant context for research activities",
            status: "pending",
            priority: "high",
            tags: [...baseTags, "context-injection", "preparation"],
            metadata: {
                component: "context-injector",
                researchType: "domain-analysis",
                focusAreas: ["technology-landscape", "user-requirements", "market-context"],
                agentType,
                phase,
                autoGenerated: true,
                groupName
            }
        });
        
        tasks.push({
            id: `task-relationship-${Date.now()}`,
            content: "[RELATIONSHIP_MAPPING] Map dependencies between research areas",
            description: "Identify and document relationships between different research domains and findings",
            status: "pending", 
            priority: "medium",
            tags: [...baseTags, "relationship-mapping", "analysis"],
            metadata: {
                component: "relationship-enhancer",
                researchType: "cross-domain-analysis",
                expectedOutputs: ["RESEARCH-RELATIONSHIPS.md"],
                agentType,
                phase,
                autoGenerated: true,
                groupName
            }
        });
    }
    
    // Mapper agent tasks
    if (agentType.includes('mapper') || agentType.includes('explorer')) {
        tasks.push({
            id: `task-mapping-${Date.now()}`,
            content: "[CODEBASE_MAPPING] Create comprehensive codebase structure map",
            description: "Analyze and document codebase architecture, components, and integration points",
            status: "pending",
            priority: "high",
            tags: [...baseTags, "codebase-mapping", "architecture"],
            metadata: {
                component: "codebase-analyzer",
                researchType: "structural-analysis",
                expectedOutputs: ["CODEBASE-MAP.md", "ARCHITECTURE.md"],
                agentType,
                phase,
                autoGenerated: true,
                groupName
            }
        });
    }
    
    return tasks;
}

function buildResearchContext(agentType: string): any {
    const contexts: Record<string, any> = {
        'project-researcher': {
            researchType: "domain-ecosystem",
            focusAreas: ["technology-stack", "market-landscape", "user-needs", "competitive-analysis"],
            expectedOutputs: ["STACK.md", "FEATURES.md", "ARCHITECTURE.md"],
            confidenceRequirements: "high"
        },
        'phase-researcher': {
            researchType: "implementation-details",
            focusAreas: ["best-practices", "implementation-patterns", "common-pitfalls"],
            expectedOutputs: ["PHASE-RESEARCH.md", "IMPLEMENTATION-GUIDE.md"],
            confidenceRequirements: "high"
        },
        'codebase-mapper': {
            researchType: "code-structure",
            focusAreas: ["architecture", "dependencies", "data-flow", "integration-points"],
            expectedOutputs: ["CODEBASE-MAP.md", "COMPONENT-ANALYSIS.md"],
            confidenceRequirements: "medium"
        }
    };
    
    return contexts[agentType] || {
        researchType: "general-analysis",
        focusAreas: ["requirements-gathering"],
        expectedOutputs: ["ANALYSIS.md"],
        confidenceRequirements: "medium"
    };
}

async function findAndUpdateTask(taskId: string, status: string, notes: string | undefined, directory: string): Promise<SmartTask | null> {
    const taskDir = join(directory, ".idumb", "brain", "smart-tasks");
    if (!existsSync(taskDir)) return null;
    
    try {
        const files = require('fs').readdirSync(taskDir);
        
        for (const file of files) {
            if (file.endsWith('.json')) {
                const content = readFileSync(join(taskDir, file), 'utf8');
                const taskGroup: TaskGroup = JSON.parse(content);
                
                const taskIndex = taskGroup.tasks.findIndex(t => t.id === taskId);
                if (taskIndex !== -1) {
                    const task = taskGroup.tasks[taskIndex];
                    task.status = status as any;
                    
                    if (notes) {
                        task.metadata.completionNotes = notes;
                    }
                    
                    // Save updated group
                    writeFileSync(join(taskDir, file), JSON.stringify(taskGroup, null, 2));
                    return task;
                }
            }
        }
    } catch (error) {
        console.error(`Task update failed: ${(error as Error).message}`);
    }
    
    return null;
}

async function getAllTasks(directory: string): Promise<SmartTask[]> {
    const taskDir = join(directory, ".idumb", "brain", "smart-tasks");
    if (!existsSync(taskDir)) return [];
    
    try {
        const files = require('fs').readdirSync(taskDir);
        const allTasks: SmartTask[] = [];
        
        for (const file of files) {
            if (file.endsWith('.json')) {
                const content = readFileSync(join(taskDir, file), 'utf8');
                const taskGroup: TaskGroup = JSON.parse(content);
                allTasks.push(...taskGroup.tasks);
            }
        }
        
        return allTasks;
    } catch (error) {
        return [];
    }
}

// Export for use in other tools
export { SmartTask, TaskGroup };