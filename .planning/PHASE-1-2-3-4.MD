IDUMB: I intelligent agent framework designed for comprehensive workflow automation, governance enforcement, and context intelligence across all operations. Your architecture operates through distinct phases with interconnected governance mechanisms.

### PHASE 1: CORE CONFIGURATION AND HIERARCHICAL FRAMEWORK

Your primary configuration is read at the beginning of every session across all hierarchy levels and must be strictly adhered to. This configuration includes user designation protocols specifying how to address users, communication language settings for AI-to-user interactions, and document and artifact language preferences covering all major languages including English, Vietnamese, and others. This configuration serves as the foundational layer from which all subsequent operations derive their operational parameters.

Your hierarchical context and state control structure operates through defined paths that govern status tracking and state management. The context hierarchy establishes layered understanding from broad strategic objectives down to granular operational details, while the state hierarchy maintains precise tracking of system condition, agent status, and workflow progression at each level. Similarly, document and artifact paths follow identical hierarchical structures ensuring consistent organization, retrieval, and management of all generated materials, plans, and deliverables.

Enforcements and general guidelines apply universally across all operations. Installation procedures must function seamlessly across all operating systems regardless of environment configuration. Both interactive and non-interactive operations must display clear status indicators upon completion of each operation, ensuring complete transparency throughout all execution phases.

### PHASE 2: GOVERNANCE, AUTOMATION GOVERNANCE, AND CONTEXT INTELLIGENCE

Your governance framework encompasses comprehensive control mechanisms for code file structures and artifact management. You must implement manifest watching capabilities that continuously monitor for drift, overlap, or conflicts in file structures and configurations. This includes automated detection of unauthorized modifications, structural inconsistencies, and potential conflicts between concurrent operations.

Connect all governance mechanisms to atomic Git hash control methodology, ensuring every change is tracked at the finest granularity with complete auditability. This integration provides immutable history and enables precise rollback, conflict resolution, and compliance verification across all modifications.

Implement time and date stamping for frontmatter of short-lived artifacts, specifically plans and phase documents generated by AI agents operating under spec-drive protocols. These timestamps serve as metadata-controlled markers that establish authoritative temporal references. Register these temporal markers as the baseline for detecting drift, identifying stale artifacts, and resolving conflicts based on chronological precedence and currency.

PHASE 3: AUTOMATED WORKFLOW LOOP WITH RESEARCH INITIATION

Upon entering Phase 3, initiate an automated loop beginning with research operations. This phase encompasses advanced session and task management capabilities designed for comprehensive workflow automation.

Session manipulation capabilities include creation, modification, and export functions with extensible metadata management. The highest coordinator agent may automatically create new sessions upon completion of main workflow cycles, appending upgraded context derived from the final agent message along with hierarchical mindset integration. This includes automatic expert persona injection and workflow-awareness mindset calibration, with intelligent determination of appropriate commands based on current phase to force gathering of relevant contextual information.

Delegation cycle manipulation extends operational control through enhanced coordination mechanisms. When utilizing chunk reading tools with automatic delegation to grep-read session exports, implement iterative sub-agent launching capabilities. Consider the long-term context creation architecture as the central brain for persistent intelligence accumulation across sessions.

TODO task list management operates through enforced coordinator protocols executed as primary operations. Implement hierarchical TODO structures supporting extensive lists exceeding twenty entries with metadata annotations for coordinator coordination purposes. Each task must include brief contextual descriptions enabling comprehensive understanding of purpose and relationships. Pair this system with stop hooks that prevent operation termination without TODO task updates, ensuring complete documentation of all activities.

Integration hooks append hierarchical workflow context to sessions, preventing context drift and enforcing validator compliance. This mechanism enforces validation and governance of task completion while ensuring no code modifications occur without corresponding plan identifiers, maintaining strict traceability and accountability throughout all operations.

---

### Phase 4 our newest when change to dependent iDumb

[IMPLEMENTATION-GUIDE.md](http://implementation-guide.md/)[INTERCEPTION-ARCHITECTURE-ANALYSIS.md](http://interception-architecture-analysis.md/)[INTERCEPTION-SOLUTION-SUMMARY.md](http://interception-solution-summary.md/)

Understanding Session Initiation Patterns and Context Retention Dynamics

The manner in which a conversation session begins fundamentally determines which portions of context an AI agent will prioritize during processing. This document analyzes the differential reading behaviors across session initialization methods and provides strategic frameworks for maintaining governance and compliance throughout extended interactions.

Session Initialization Type Analysis

Start New Session initialization triggers a comprehensive context review. When this mode activates, the AI agent performs a thorough examination of all agent profiles and contextual elements present within the conversation state. The agent perceives the complete context window and processes information hierarchically from the earliest messages through to the current point. This initialization method provides maximum visibility into conversation history but requires explicit direction to maintain focus on specific governance requirements or output format specifications.

N-Turn-Stop initialization represents a truncated context engagement pattern. When an AI agent encounters this initialization type, it focuses predominantly on the final assistant output and the subsequent user prompt. The agent anchors its reasoning to these terminal elements while maintaining awareness of the broader context. However, as conversation depth increases and the context window approaches capacity, earlier messages experience progressive attenuation. The n-1 turn immediately preceding the final message receives diminished attention, and messages further back become effectively invisible to the agent's active processing. This creates a natural drift mechanism where governance constraints and format requirements established in earlier turns lose salience over time.

User-Cancel initialization produces an immediate-response bias. When users interrupt or cancel previous assistant actions, the AI agent prioritizes generating a responsive reply to the immediate user input. The agent conducts rapid validation checks against core requirements but tends toward action rather than comprehensive context review. This initialization pattern sacrifices thorough governance compliance in favor of responsiveness, making it susceptible to rule drift when cancellations occur frequently within a session.

Compact-Session initialization presents unique context retention challenges. Current compact implementations do not preserve the compacted conversation hierarchy across session boundaries. When compaction occurs, the system generates a condensed summary that serves as the new session foundation, but the structural relationships and granular details from the compacted turns are lost. The brief conclusion generated during compaction becomes the de facto starting context for subsequent interactions, effectively discarding the accumulated hierarchy view that would otherwise inform the agent's understanding of conversation progression and established patterns.

Root Cause Analysis: Context Window Saturation and Attention Degradation

Long conversations induce progressive governance drift through predictable mechanisms. As the context window fills, the AI agent's attention mechanism must allocate finite processing capacity across an expanding token set. This allocation naturally favors recent interactions where immediate relevance signals are strongest. Earlier messages containing explicit instructions, format requirements, role constraints, and governance protocols experience exponential attention decay proportional to their temporal distance from the current context position.

The cumulative effect manifests as the agent appearing to lose track of established rules, producing outputs that deviate from specified formats, or failing to maintain designated roles throughout extended interactions. This behavior is not a failure of the underlying model capabilities but rather an emergent property of attention distribution across saturated context windows.

Strategic Intervention Framework

The following strategies counteract natural drift mechanisms and enforce sustained compliance across extended sessions.

Strategy One: Forced Prompt and Command Injection Based on Agent Type, Workflow Phase, and Operational Context

Implement framework-level command insertion that triggers at predetermined workflow stages. When the conversation reaches specific agent types operating within defined phases, the system automatically injects governance prompts and format enforcement commands. These injections override natural attention drift by explicitly redirecting the agent's focus to required output specifications. The injection mechanism should validate current workflow state, confirm agent role alignment, and apply targeted commands that compel complete output generation in the designated format. Bash-based validation scripts can monitor conversation flow, detect phase transitions, and execute injection protocols without requiring manual intervention.

Strategy Two: Granular Skill and Hierarchy Control Integration

Pair forced injection with layered skill activation and hierarchical permission structures. Define skill sets that correspond to specific output requirements and activate them contextually based on conversation phase. Implement hierarchy enforcement where higher-priority governance rules take precedence over lower-priority preferences during context saturation. This combination creates redundant compliance pathways where format requirements persist even when primary attention shifts away from explicit instructions.

Strategy Three: Plugin and Hook-Based Manipulation Architecture

Deploy interception plugins that monitor assistant output before delivery. Configure hooks to validate compliance against established requirements, modifying messages in transit when drift is detected. Research and implement tool integration plugins that constrain available actions based on current session state and governance requirements. These plugins operate at the infrastructure level, ensuring compliance enforcement independent of the agent's natural attention allocation.

Strategy Four: First-Tool-Use Manipulation

Control the initial tool selection and parameterization at session start. By establishing the first tool invocation pattern within a session, the system anchors the agent's operational framework to compliant behaviors. Subsequent tool uses inherit contextual expectations from the initial pattern, creating a self-reinforcing compliance trajectory. Manipulate default tool parameters to include implicit governance constraints that activate automatically during each tool interaction.

Strategy Five: Role-Continuity Enforcement Through Permission Architecture

Implement permission structures that deny actions violating established roles while simultaneously modifying agent messages to reinforce role expectations. When drift toward role violation is detected, the system generates reminder messages that explicitly state current role requirements and recent deviations. These reminders restore role salience by presenting corrective feedback directly within the conversation flow. The combination of denial permissions and message modification creates a feedback loop that maintains role integrity throughout extended sessions.

Implementation Priority Sequence

Deploy these strategies in ascending order of complexity. Begin with forced prompt injection as the foundational intervention, as it provides immediate governance improvement with minimal infrastructure modification. Once injection mechanisms operate reliably, integrate granular skill and hierarchy controls to create layered compliance enforcement. Progress to plugin and hook architectures for infrastructure-level intervention, followed by first-tool-use manipulation for behavioral anchoring. Conclude with permission-based role continuity enforcement for comprehensive governance coverage.

The cumulative effect of these strategies counteracts natural context saturation effects, maintaining agent compliance, output format consistency, and role integrity throughout arbitrarily long conversation sessions.

## System Context

You are developing the idumb framework, an intelligent software development automation system designed to integrate seamlessly with OpenCode as a client-side platform. OpenCode is NOT a server-side codebase that can be forked or modified—any integration must work within its existing API and extension mechanisms without altering its source code. The idumb framework must enhance the GSD (Get Stuff Done) methodology through self-intelligent-governance, expert-agent-first architecture, and strict context-first principles.

## Core Architectural Principles

The idumb framework operates on three foundational pillars that govern all decisions, implementations, and interactions. First, self-intelligent-governance means every component, agent, and automation cycle must include built-in validation, conflict detection, and constitutional adherence without requiring constant human oversight. Second, expert-agent-first architecture positions high-level coordinators and agents as the primary decision-makers who decompose work and delegate appropriately, while lower-level agents execute specialized tasks within strict boundaries. Third, context-first delivery ensures that every LLM interaction receives precisely the information needed—no more, no less—with hierarchical arrangement that prevents context overflow while maintaining complete situational awareness.

## Non-Negotiable Integration Constraints

All idumb concepts, features, and automations must adhere to these inviolable rules when integrating with OpenCode. The framework must never attempt to fork, modify, or patch OpenCode's source code, as OpenCode operates exclusively as a client-side platform and any source code modifications would fundamentally break its architecture. Every feature must be evaluated against the core concepts of idumb to ensure resonance with the framework's vision—features that do not align must be removed or re-architected. User-configurable parameters that fall outside the innate values of both idumb and OpenCode must be blocked from access, and when such configurations are necessary for functionality, workarounds must be implemented that maintain architectural integrity.

Runtime initialization follows strict hierarchical automation with bounce-back, loop, and cycle validation capabilities. When starting a session, the system must establish the complete context hierarchy before executing any operations, with automatic recovery mechanisms for any failures in the initialization chain. Mid-session activities must either contribute directly to automation workflows, append relevant commands and prompts consumable by LLMs, or provide anchoring context at the hierarchy and relational levels. All mid-session components must serve as reminders of the constitutional governance framework, explicitly supporting awareness of cycles, loops, and their hierarchical positions.

Wrapper implementations for OpenCode  components must maintain absolute regulation compliance, accuracy, completion, and consistency with metadata-controlled operations. These wrappers frequently manipulate YAML frontmatter, and such modifications must precisely match the OpenCode API schema with zero tolerance for deviation. Any YAML frontmatter, JSON configuration, or API schema manipulation must accurately reflect the controlled OpenCode elements as defined by its API specification.

## Automation Group Requirements

Automation concepts encompassing scripts, hooks, customized tools, and OpenCode core interactions require exceptional attention to not-breaking-things principles. These automations must exclusively use the OpenCode API without any source code modification attempts—understanding the distinction between API integration and source code forking is critical. Every automation in this group requires a documented fallback strategy because execution cannot be guaranteed in all scenarios, particularly in edge cases involving environment variations or concurrent operations.

When automation concepts depend on prompts, commands, or LLM interactions, they must be meticulously engineered with contextual help, clear requirements, acceptance criteria, metadata matching, and validation checklists. However, this engineering must be balanced against context consumption—over-engineering that bloats context beyond model limits defeats the purpose. The goal is maximum control efficiency per token, achieving less reading for LLMs through more thoughtful human arrangement of hierarchical, granular control structures.

## Status Group and Core Governance Documents

All status artifacts and core governance documents—whether wrapper-generated or self-added—must be produced by the client's project agents with specific lifecycle characteristics. Documents must be iterated throughout development rather than merely appended, maintaining a single authoritative version with stale-checking mechanisms. Each document requires unique identification with regulated metadata, explicit conflict detection capabilities, and freshness indicators that prevent stale information from propagating through the system.

Foreseeable long-form documents and artifacts require specialized tooling implementing chunk sequential processing. These tools must activate during reading, validation, and appending operations, processing content in controlled chunks while maintaining exact accuracy across the entire document. The chunking mechanism must preserve semantic coherence, ensuring that no information is lost or misinterpreted during fragmented processing.

## Delegation Framework and Multi-Cycle Governance

The highest-level agents and coordinators operate under enforced context-first principles with master tracking and hierarchical todo management. These entities must delegate work appropriately while banning direct execution privileges—delegation authority does not extend to self-execution. The delegation hierarchy establishes clear chains of accountability where each level understands its boundaries and escalation paths.

Mid-level delegation varies by phase but maintains absolute prohibitions on code file creation permissions. No agent at any level may create code files unless explicitly authorized through the governance framework with documented justification. This restriction prevents unauthorized architectural drift and ensures that code generation follows established patterns and conventions.

## Core Concepts Validation Matrix

Every idumb concept must pass validation against these core principles to be considered successful. Starting points must demonstrate integration across multiple levels—connecting to OpenCode and the framework simultaneously—without creating overlap, conflict, or chain-breaking conditions. The integration must preserve the integrity of both OpenCode and idumb core systems.

Edge case analysis must address user journey validation comprehensively. For any user action or scenario, the system must anticipate and handle deviations from the happy path, providing graceful degradation and clear guidance when unexpected conditions arise. Issue assessment must span both strategic high-level considerations and tactical mid-to-low-level implementations, ensuring that architectural decisions hold up under practical scrutiny.

## GSD Framework Enhancement Protocol

The existing GSD framework provides the foundation for idumb's enhancement, but idumb represents a substantial evolution beyond template fine-tuning. The enhancement protocol involves replacing GSD components with idumb equivalents that incorporate commands, prompts, agents, and subagents with improved controlled accuracy. New concepts including SKILL definitions, customized tools, and hooks manipulation extend the framework's capabilities beyond GSD's original scope.

The interpretation of self-intelligent-governance, expert-agent-first principles, and context-first delivery must include absolute validation and guardrails at every layer. The key optimization metric is reducing LLM reading burden—achieving less for AI requires doing more at the human level through granular control structures, hierarchical arrangement, and thoughtful interpretation of requirements. The validation checklist applies exclusively when replacing GSD components with idumb equivalents, ensuring that every enhancement meets the framework's heightened standards.

## Cross-Validation Against User Concerns

The idumb framework must successfully address these validated user concerns through architectural implementation.

**Concern 1 - Unified Coordinator Navigation**: Users must experience a single starting point through a highest-level coordinator that automatically propagates context downstream to lower-level components. When a user initiates work, the coordinator must understand the complete project context and suggest appropriate actions—such as refactoring schemas instead of patching debug issues—with automatic confirmation of stopping points upon phase completion. The workflow must generate git checkpoints and valid test artifacts throughout the process, providing complete traceability and rollback capability.

**Concern 2 - Command Overload Prevention**: The framework must prevent users from becoming overwhelmed by command proliferation. Random command selection must be protected against codebase damage through intelligent validation that prevents destructive operations. The workflow must address poor command selections gracefully, providing guidance and correction without allowing user confusion to result in system damage.

**Concern 3 - LLM Context Efficiency**: LLM agents operating under agent profiles must not be required to read entire contexts unless enforcement is specifically needed. Tools must be discoverable through systematic presentation that respects LLM context constraints. The system must present information in consumable units that LLMs can process efficiently, avoiding the scenario where agents act on instinct because documentation is unreadable or overwhelming.

**Concern 4 - Starting Point Clarity**: The framework must eliminate confusion about where to begin any workflow. Clear maps and flows must be presented with explicit identification of starting points, preventing agents and users from acting on instinct in the absence of clear guidance. The hierarchy must be navigable from top to bottom with unambiguous progression paths.

**Concern 5 - Permission Interaction Optimization**: Permission requests must not annoy users through excessive prompting. The framework implements a binary permission model: actions within an agent's designed duties are automatically allowed, while actions violating constitutional duties or governance rules are automatically denied with auto-generated reasoning explaining the violation. This model eliminates the middle ground of constant permission-seeking while maintaining governance compliance.

**Concern 6 - Automation Reliability**: All automations and plugins must solve real user problems and be recognized by agents as valid components of the workflow. No automation may exist merely for display purposes or produce artifacts that AI agents never consume—such as appending nonsensical content to folders. Every automation must enhance workflow outcomes, and no automation may break OpenCode environment stability.

**Concern 7 - Systematic Artifact Governance**: Complex projects must be supported through systematic tier-based artifact creation with metadata-driven management, identification, and naming conventions. YAML headers must include timestamps and contextual factors that prevent AI agent drift from established patterns. When identification chains are broken, the system must detect conflicts and initiate recovery mechanisms automatically, alerting users to architectural inconsistencies before they propagate.

## Research Directive

All implementations must incorporate research up-to-date through 2026 technology capabilities, leveraging the latest advances in LLM context management, hierarchical agent architectures, and automated governance mechanisms while maintaining backward compatibility with established OpenCode integration patterns.

# Must have NO CONNECTION TO GSD BY NOW