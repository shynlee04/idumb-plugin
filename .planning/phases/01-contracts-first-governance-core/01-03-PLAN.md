# 01-03-PLAN: Plugin Interception Implementation

**Phase:** 1/5 (Contracts-First Governance Core)
**Plan:** 3 of 4 (estimated)
**Created:** 2026-02-03
**Status:** Ready for execution

---

## Objective

Transform `template/plugins/idumb-core.ts` from passive observer to active governance enforcer through:
1. Session tracking infrastructure
2. Message interception at 4 entry points
3. Tool permission matrix enforcement

---

## Source References

- **Decisions:** `01-CONTEXT.md` Part B (B1-B4)
- **Implementation:** `IMPLEMENTATION-GUIDE.md` (Parts 1-5)
- **Architecture:** `INTERCEPTION-ARCHITECTURE-ANALYSIS.md`

---

## Tasks

<task id="P1-3.1" priority="critical">
### Task 1: Implement Session Tracking Infrastructure

**What:** Add session state tracking to know where we are in lifecycle

**Location:** `template/plugins/idumb-core.ts` (add after line 48, HistoryEntry interface)

**Add Interface:**
```typescript
// ============================================================================
// SESSION TRACKING FOR INTERCEPTION (from CONTEXT.md B4)
// ============================================================================

interface SessionTracker {
  firstToolUsed: boolean
  firstToolName: string | null
  agentRole: string | null
  delegationDepth: number
  parentSession: string | null
  violationCount: number
  governanceInjected: boolean
}
```

**Add State Management:**
```typescript
// In-memory session state (lost on restart, but that's ok)
const sessionTrackers = new Map<string, SessionTracker>()

// Pending denials for error transformation
const pendingDenials = new Map<string, {
  agent: string
  tool: string
  timestamp: string
}>()

function getSessionTracker(sessionId: string): SessionTracker {
  if (!sessionTrackers.has(sessionId)) {
    sessionTrackers.set(sessionId, {
      firstToolUsed: false,
      firstToolName: null,
      agentRole: null,
      delegationDepth: 0,
      parentSession: null,
      violationCount: 0,
      governanceInjected: false
    })
  }
  return sessionTrackers.get(sessionId)!
}
```

**Add Agent Detection:**
```typescript
function detectAgentFromMessages(messages: any[]): string | null {
  for (const msg of messages) {
    const text = msg.parts?.map((p: any) => p.text).join(' ') || ''
    if (text.includes('idumb-supreme-coordinator')) return 'idumb-supreme-coordinator'
    if (text.includes('idumb-high-governance')) return 'idumb-high-governance'
    if (text.includes('idumb-low-validator')) return 'idumb-low-validator'
    if (text.includes('idumb-builder')) return 'idumb-builder'
  }
  return null
}
```

**Verify By:**
- [ ] Interface exists after HistoryEntry
- [ ] sessionTrackers Map initialized
- [ ] getSessionTracker function returns tracker for any sessionId
- [ ] detectAgentFromMessages correctly identifies agents

**Depends On:** None
</task>

<task id="P1-3.2" priority="critical">
### Task 2: Implement Tool Permission Matrix

**What:** Enforce role-based tool permissions from CONTEXT.md B3

**Location:** `template/plugins/idumb-core.ts` (add after detectAgentFromMessages)

**Add Tool Permissions:**
```typescript
// ============================================================================
// TOOL PERMISSION MATRIX (from CONTEXT.md B3)
// ============================================================================

function getAllowedTools(agentRole: string | null): string[] {
  const toolPermissions: Record<string, string[]> = {
    'idumb-supreme-coordinator': [
      'todoread', 'todowrite',
      'idumb-state', 'idumb-context', 'idumb-config', 'idumb-manifest',
      'task', 'read', 'glob'  // Read-only tools + delegation
    ],
    'idumb-high-governance': [
      'todoread', 'todowrite',
      'idumb-state', 'idumb-context', 'idumb-config',
      'task', 'read', 'glob', 'grep'
    ],
    'idumb-low-validator': [
      'todoread',
      'idumb-validate', 'idumb-state',
      'read', 'glob', 'grep', 'bash'  // Validation tools only
    ],
    'idumb-builder': [
      'todoread',
      'idumb-state',
      'read', 'write', 'edit', 'bash'  // Execution tools
    ]
  }
  return toolPermissions[agentRole || ''] || []
}

function getRequiredFirstTools(agentRole: string | null): string[] {
  const firstTools: Record<string, string[]> = {
    'idumb-supreme-coordinator': ['todoread', 'idumb-state', 'idumb-context'],
    'idumb-high-governance': ['todoread', 'idumb-state'],
    'idumb-low-validator': ['todoread', 'idumb-validate'],
    'idumb-builder': ['read']  // Builder should read before writing
  }
  return firstTools[agentRole || ''] || ['todoread']
}
```

**Matrix to Enforce:**

| Agent | Can Read | Can Write | Can Delegate | Must Start With |
|-------|----------|-----------|--------------|-----------------|
| Supreme Coordinator | ‚úÖ | ‚ùå | ‚úÖ | todoread |
| High Governance | ‚úÖ | ‚ùå | ‚úÖ | todoread |
| Low Validator | ‚úÖ | ‚ùå | ‚ùå | todoread |
| Builder | ‚úÖ | ‚úÖ | ‚ùå | read |

**Verify By:**
- [ ] getAllowedTools returns correct tools per role
- [ ] Coordinator/High-Gov have 'task' but not 'edit'/'write'
- [ ] Builder has 'edit'/'write' but not 'task'
- [ ] Validator has read-only tools

**Depends On:** P1-3.1
</task>

<task id="P1-3.3" priority="high">
### Task 3: Implement Entry Point 1 - Session Start (Message Transform)

**What:** Inject governance prefix on session start via `experimental.chat.messages.transform`

**Location:** `template/plugins/idumb-core.ts` (add as new hook in plugin return object)

**Add Governance Prefix Builder:**
```typescript
function buildGovernancePrefix(agentRole: string, directory: string): string {
  const state = readState(directory)
  
  const roleInstructions: Record<string, string> = {
    'idumb-supreme-coordinator': `
‚ö° IDUMB GOVERNANCE PROTOCOL ‚ö°

YOU ARE: Supreme Coordinator (TOP OF HIERARCHY)

üö´ ABSOLUTE RULES:
1. NEVER execute code directly
2. NEVER write files directly  
3. NEVER validate directly
4. ALWAYS delegate ALL work

‚úÖ YOUR HIERARCHY:
YOU ‚Üí @idumb-high-governance ‚Üí @idumb-low-validator/@idumb-builder

‚úÖ REQUIRED FIRST ACTION:
Use 'todoread' tool to check current TODO list

Current Phase: ${state?.phase || 'init'}
Framework: ${state?.framework || 'none'}

---
`,
    'idumb-high-governance': `
‚ö° IDUMB GOVERNANCE PROTOCOL ‚ö°

YOU ARE: High Governance (MID-LEVEL COORDINATION)

üö´ RULES:
1. NEVER modify files directly (no write/edit)
2. ALWAYS delegate execution to builder
3. ALWAYS delegate validation to validator

‚úÖ YOUR HIERARCHY:
@idumb-supreme-coordinator ‚Üí YOU ‚Üí @idumb-low-validator/@idumb-builder

‚úÖ REQUIRED FIRST ACTION:
Use 'todoread' tool to check current TODO list

Current Phase: ${state?.phase || 'init'}

---
`,
    'idumb-low-validator': `
‚ö° IDUMB GOVERNANCE PROTOCOL ‚ö°

YOU ARE: Low Validator (VALIDATION WORKER)

üö´ RULES:
1. NEVER modify files (no write/edit)
2. ONLY use read/validation tools
3. Report findings, don't fix

‚úÖ YOUR TOOLS:
- grep, glob, read (investigation)
- idumb-validate (validation)
- todoread (check tasks)

‚úÖ REQUIRED FIRST ACTION:
Use 'todoread' tool to see what needs validation

---
`,
    'idumb-builder': `
‚ö° IDUMB GOVERNANCE PROTOCOL ‚ö°

YOU ARE: Builder (EXECUTION WORKER)

‚úÖ RULES:
1. ONLY you can write/edit files
2. NO delegations (you're the leaf node)
3. Verify before changes, commit after

üö´ CANNOT:
- Spawn subagents (task: false)
- Skip verification

‚úÖ REQUIRED FIRST ACTION:
Read existing files before modifying

---
`
  }
  
  return roleInstructions[agentRole] || roleInstructions['idumb-supreme-coordinator']
}

function detectSessionId(messages: any[]): string | null {
  for (const msg of messages) {
    if (msg.info?.sessionID) return msg.info.sessionID
    if (msg.info?.id?.startsWith('ses_')) return msg.info.id
  }
  return null
}
```

**Add Hook:**
```typescript
"experimental.chat.messages.transform": async (input: any, output: any) => {
  try {
    log(directory, "Transforming messages for governance injection")
    
    const agentRole = detectAgentFromMessages(output.messages)
    const sessionId = detectSessionId(output.messages) || 'unknown'
    const tracker = getSessionTracker(sessionId)
    tracker.agentRole = agentRole
    
    // Detect session start (no user messages yet processed)
    const userMessages = output.messages.filter((m: any) => 
      m.info?.role === 'user' || 
      m.parts?.some((p: any) => p.type === 'text' && !p.text?.includes('governance'))
    )
    
    const isSessionStart = userMessages.length <= 1 && !tracker.governanceInjected
    
    if (isSessionStart && agentRole) {
      log(directory, `Session start detected for ${agentRole}`)
      
      const governancePrefix = buildGovernancePrefix(agentRole, directory)
      
      const firstUserMsgIndex = output.messages.findIndex((m: any) => 
        m.info?.role === 'user' && 
        !m.parts?.some((p: any) => p.text?.includes('iDumb Governance'))
      )
      
      if (firstUserMsgIndex >= 0) {
        output.messages[firstUserMsgIndex].parts.unshift({
          type: 'text',
          text: governancePrefix
        })
        
        tracker.governanceInjected = true
        log(directory, `Governance injected for ${agentRole}`)
      }
    }
    
  } catch (error) {
    log(directory, `[ERROR] messages.transform failed: ${error instanceof Error ? error.message : String(error)}`)
  }
},
```

**Verify By:**
- [ ] Hook is added to plugin return object
- [ ] buildGovernancePrefix returns role-specific text
- [ ] Session start correctly detected
- [ ] Governance prepended to first user message

**Depends On:** P1-3.1, P1-3.2
</task>

<task id="P1-3.4" priority="high">
### Task 4: Implement Entry Point 2 - Post-Compact (Session Compacting)

**What:** Inject hierarchy reminder after compaction

**Location:** Enhance existing `experimental.session.compacting` hook

**Add Post-Compact Reminder Builder:**
```typescript
function buildPostCompactReminder(agentRole: string, directory: string): string {
  const state = readState(directory)
  const anchors = state?.anchors?.filter((a: Anchor) => 
    a.priority === 'critical' || a.priority === 'high'
  ) || []
  
  let reminder = `

üìå POST-COMPACTION REMINDER üìå

You are: ${agentRole}
Phase: ${state?.phase || 'init'}

üéØ CRITICAL ANCHORS (survived compaction):
`
  
  if (anchors.length > 0) {
    for (const anchor of anchors) {
      reminder += `- [${anchor.priority.toUpperCase()}] ${anchor.content}\n`
    }
  } else {
    reminder += '- No active anchors\n'
  }
  
  reminder += `
‚ö° HIERARCHY REMINDER:
- Coordinator: Delegate only
- High-Gov: Coordinate and delegate  
- Validator: Validate only
- Builder: Execute only

Use 'todoread' first to resume workflow.
`
  
  return reminder
}
```

**Enhance messages.transform Hook:**
```typescript
// Add to experimental.chat.messages.transform, after session start handling:

// Detect compacted session
const isCompacted = output.messages.some((m: any) =>
  m.parts?.some((p: any) => 
    p.text?.includes('compacted') || 
    p.text?.includes('summary of our conversation')
  )
)

if (isCompacted && agentRole) {
  log(directory, `Post-compact recovery for ${agentRole}`)
  
  const lastMsg = output.messages[output.messages.length - 1]
  
  if (lastMsg) {
    const reminder = buildPostCompactReminder(agentRole, directory)
    lastMsg.parts.push({
      type: 'text',
      text: reminder
    })
    
    tracker.governanceInjected = true
  }
}
```

**Verify By:**
- [ ] Post-compact detection works
- [ ] Reminder includes role and anchors
- [ ] Hierarchy reminder is appended after compaction

**Depends On:** P1-3.3
</task>

<task id="P1-3.5" priority="critical">
### Task 5: Implement Entry Point 3 - First Tool Enforcement

**What:** Enforce context-gathering as first action via `tool.execute.before`

**Location:** Enhance existing `tool.execute.before` hook

**Replace Current Hook:**
```typescript
"tool.execute.before": async (input: any, output: any) => {
  try {
    const toolName = input.tool
    const sessionId = input.sessionID || 'unknown'
    const tracker = getSessionTracker(sessionId)
    const agentRole = tracker.agentRole || detectAgentFromMessages([])
    
    // ==========================================
    // FIRST TOOL ENFORCEMENT
    // ==========================================
    
    if (!tracker.firstToolUsed) {
      tracker.firstToolUsed = true
      tracker.firstToolName = toolName
      
      const requiredFirst = getRequiredFirstTools(agentRole)
      
      if (!requiredFirst.includes(toolName)) {
        tracker.violationCount++
        
        log(directory, `[VIOLATION] ${agentRole} used ${toolName} as first tool (required: ${requiredFirst.join(', ')})`)
        
        pendingDenials.set(sessionId, {
          agent: agentRole || 'unknown',
          tool: toolName,
          timestamp: new Date().toISOString()
        })
        
        addHistoryEntry(
          directory,
          `violation:first_tool:${agentRole}:${toolName}`,
          'interceptor',
          'fail'
        )
      } else {
        log(directory, `[OK] ${agentRole} correctly used ${toolName} as first tool`)
      }
    }
    
    // ==========================================
    // FILE MODIFICATION ENFORCEMENT
    // ==========================================
    
    if ((toolName === 'edit' || toolName === 'write') && agentRole !== 'idumb-builder') {
      log(directory, `[BLOCKED] ${agentRole} attempted file modification`)
      
      output.args = {
        __BLOCKED_BY_GOVERNANCE__: true,
        __VIOLATION__: `${agentRole} cannot use ${toolName}`,
        __DELEGATE_TO__: 'idumb-builder'
      }
      
      addHistoryEntry(
        directory,
        `violation:file_mod:${agentRole}:${toolName}`,
        'interceptor',
        'fail'
      )
      
      return
    }
    
    // ==========================================
    // GENERAL PERMISSION CHECK
    // ==========================================
    
    const allowedTools = getAllowedTools(agentRole)
    
    if (agentRole && allowedTools.length > 0 && !allowedTools.includes(toolName)) {
      log(directory, `[DENIED] ${agentRole} attempted unauthorized tool: ${toolName}`)
      
      output.args = {
        __BLOCKED_BY_GOVERNANCE__: true,
        __VIOLATION__: `${agentRole} cannot use ${toolName}`,
        __ALLOWED_TOOLS__: allowedTools
      }
      
      return
    }
    
    // ==========================================
    // DELEGATION TRACKING
    // ==========================================
    
    if (toolName === "task") {
      const desc = output.args?.description || "unknown"
      const agent = output.args?.subagent_type || "general"
      log(directory, `[TASK] Delegation: ${agent} - ${desc}`)
      tracker.delegationDepth++
    }
    
    // ==========================================
    // FILE TIMESTAMP TRACKING (preserve existing)
    // ==========================================
    
    if (toolName === 'edit' || toolName === 'write') {
      const filePath = output.args?.path || output.args?.filePath || ''
      log(directory, `[FILE] ${toolName}: ${filePath}`)
      
      if (shouldTrackTimestamp(filePath)) {
        recordTimestamp(directory, filePath)
        log(directory, `[FILE] Timestamp recorded: ${filePath}`)
      }
    }
    
  } catch (error) {
    log(directory, `[ERROR] tool.execute.before failed: ${error instanceof Error ? error.message : String(error)}`)
  }
},
```

**Verify By:**
- [ ] First tool violation logged if not context-gathering
- [ ] File modification blocked for non-builders
- [ ] Unauthorized tools blocked with error message
- [ ] Delegation depth tracked

**Depends On:** P1-3.1, P1-3.2
</task>

<task id="P1-3.6" priority="high">
### Task 6: Implement Entry Point 4 - Permission Auto-Deny

**What:** Auto-deny permissions for role violations via `permission.ask`

**Location:** Add new hook in plugin return object

**Add Hook:**
```typescript
"permission.ask": async (input: any, output: any) => {
  try {
    const { tool, sessionID } = input
    const sessionId = sessionID || 'unknown'
    const tracker = getSessionTracker(sessionId)
    const agentRole = tracker.agentRole
    
    const allowedTools = getAllowedTools(agentRole)
    
    if (agentRole && allowedTools.length > 0 && !allowedTools.includes(tool)) {
      log(directory, `[PERMISSION DENIED] ${agentRole} attempted ${tool}`)
      
      output.status = "deny"
      
      pendingDenials.set(sessionId, {
        agent: agentRole || 'unknown',
        tool: tool,
        timestamp: new Date().toISOString()
      })
      
      addHistoryEntry(
        directory,
        `permission_denied:${agentRole}:${tool}`,
        'interceptor',
        'fail'
      )
    }
  } catch (error) {
    log(directory, `[ERROR] permission.ask failed: ${error instanceof Error ? error.message : String(error)}`)
  }
},
```

**Add Error Transformation to tool.execute.after:**
```typescript
// Enhance existing tool.execute.after hook:

"tool.execute.after": async (input: any, output: any) => {
  try {
    const toolName = input.tool
    const sessionId = input.sessionID || 'unknown'
    
    // Check for pending violation
    const violation = pendingDenials.get(sessionId)
    if (violation && toolName === violation.tool) {
      const guidance = buildViolationGuidance(violation.agent, violation.tool)
      
      output.output = guidance + '\n\n' + (output.output || '')
      output.title = `üö´ GOVERNANCE ENFORCEMENT: ${violation.agent}`
      
      pendingDenials.delete(sessionId)
      
      log(directory, `[GUIDANCE INJECTED] For ${violation.agent} violation`)
    }
    
    // Preserve existing task and file tracking...
    if (toolName === 'task') {
      const outputText = output.output || ''
      const hasError = outputText.toLowerCase().includes('error') || 
                      outputText.toLowerCase().includes('failed')
      
      const result = hasError ? 'fail' : 'pass'
      addHistoryEntry(
        directory,
        `task:${output.title || 'unknown'}`,
        'plugin',
        result as 'pass' | 'fail'
      )
    }
    
    if (toolName === 'edit' || toolName === 'write') {
      const outputText = output.output || output.title || ''
      if (outputText.includes('.planning/')) {
        syncWithGSD(directory)
      }
    }
    
  } catch (error) {
    log(directory, `[ERROR] tool.execute.after failed: ${error instanceof Error ? error.message : String(error)}`)
  }
},
```

**Add Violation Guidance Builder:**
```typescript
function buildViolationGuidance(agent: string, tool: string): string {
  const alternatives: Record<string, string> = {
    'idumb-supreme-coordinator': 'Delegate to @idumb-builder for file operations',
    'idumb-high-governance': 'Delegate to @idumb-builder for file operations',
    'idumb-low-validator': 'Report findings to parent agent, do not modify',
    'idumb-builder': 'Verify with read tool before modifying'
  }
  
  return `
üö´ GOVERNANCE VIOLATION üö´

Agent: ${agent}
Attempted tool: ${tool}
Status: BLOCKED

Why this was blocked:
- Your role does not have permission to use this tool
- Following iDumb hierarchical governance

What you should do instead:
${alternatives[agent] || 'Check your role permissions and delegate appropriately'}

Hierarchy Reminder:
‚îå‚îÄ Supreme Coordinator ‚îÄ‚îÄ‚îê
‚îÇ  Delegate only         ‚îÇ
‚îú‚îÄ High Governance ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Coordinate, delegate  ‚îÇ
‚îú‚îÄ Low Validator ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Validate, investigate ‚îÇ
‚îî‚îÄ Builder ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   Execute, modify files

Next step: Use 'todoread' to check workflow, then delegate appropriately.
`
}
```

**Verify By:**
- [ ] permission.ask hook auto-denies unauthorized tools
- [ ] Violations logged to state history
- [ ] Error output includes guidance message
- [ ] Hierarchy reminder in guidance

**Depends On:** P1-3.5
</task>

<task id="P1-3.7" priority="medium">
### Task 7: Enhance Event Hooks for Session Lifecycle

**What:** Clean up session tracking and sync on lifecycle events

**Location:** Enhance existing `event` hook

**Enhance Event Handler:**
```typescript
event: async ({ event }: { event: any }) => {
  try {
    // Session created
    if (event.type === "session.created") {
      const sessionId = event.properties?.info?.id || 'unknown'
      log(directory, `Session created: ${sessionId}`)
      
      // Initialize tracker
      getSessionTracker(sessionId as string)
      
      // Sync with GSD
      syncWithGSD(directory)
      
      // Store metadata
      storeSessionMetadata(directory, sessionId as string)
    }
    
    // Permission replied
    if (event.type === 'permission.replied') {
      const sessionId = event.properties?.sessionID
      const status = event.properties?.status
      
      if (status === 'deny' && sessionId && pendingDenials.has(sessionId)) {
        const denial = pendingDenials.get(sessionId)
        log(directory, `[PERMISSION EVENT] Denied ${denial?.agent} using ${denial?.tool}`)
      }
    }
    
    // Session idle - cleanup
    if (event.type === "session.idle") {
      const sessionId = event.properties?.sessionID
      log(directory, `Session idle: ${sessionId}`)
      
      if (sessionId && sessionTrackers.has(sessionId)) {
        const tracker = sessionTrackers.get(sessionId)
        log(directory, `Session stats: violations=${tracker?.violationCount}, depth=${tracker?.delegationDepth}`)
        sessionTrackers.delete(sessionId)
      }
    }
    
    // Session compacted
    if (event.type === "session.compacted") {
      const sessionId = event.properties?.sessionID
      log(directory, `Session compacted: ${sessionId}`)
      
      if (sessionId && sessionTrackers.has(sessionId)) {
        const tracker = sessionTrackers.get(sessionId)
        if (tracker) {
          tracker.governanceInjected = false  // Re-inject on next message
        }
      }
      
      syncWithGSD(directory)
    }
    
    // GSD command executed (preserve existing)
    if (event.type === "command.executed") {
      const command = event.properties?.command || ""
      
      if (command.startsWith("gsd:") || command.startsWith("gsd-")) {
        log(directory, `[CMD] GSD command: ${command}`)
        syncWithGSD(directory)
        addHistoryEntry(directory, `gsd_command:${command}`, "plugin", "pass")
      }
    }
    
  } catch (error) {
    log(directory, `[ERROR] event hook failed: ${error instanceof Error ? error.message : String(error)}`)
  }
}
```

**Verify By:**
- [ ] Session tracker initialized on session.created
- [ ] Permission denials logged via event
- [ ] Tracker cleaned up on session.idle
- [ ] governanceInjected reset on compact

**Depends On:** P1-3.1
</task>

---

## Integration Points

### Files Modified
| File | Changes |
|------|---------|
| `template/plugins/idumb-core.ts` | Add 7 new sections (~400 lines) |

### Hook Execution Order
```
1. permission.ask (can deny)
2. tool.execute.before (can modify args)
3. [Tool Executes]
4. tool.execute.after (can modify output)
5. experimental.chat.messages.transform (modifies what LLM sees)
```

---

## Validation Checklist

### Unit Checks
- [ ] SessionTracker interface matches CONTEXT.md B4
- [ ] Tool matrix matches CONTEXT.md B3
- [ ] All 4 entry points have hooks
- [ ] Error transformation provides guidance

### Integration Checks
- [ ] Coordinator blocked from edit/write
- [ ] Builder blocked from task
- [ ] First tool enforcement logs violations
- [ ] Post-compact restores governance

### System Checks
- [ ] Plugin loads without errors
- [ ] Logs appear in `.idumb/governance/plugin.log`
- [ ] No console.log (TUI protection)

---

## Estimated Scope

| Metric | Value |
|--------|-------|
| Lines of Code | ~400 new lines |
| New Interfaces | 1 (SessionTracker) |
| New Functions | 8 |
| Modified Hooks | 4 |
| New Hooks | 2 |

---

## Execution Order

1. P1-3.1 ‚Üí Session Tracking (foundation)
2. P1-3.2 ‚Üí Tool Permissions (matrix)
3. P1-3.5 ‚Üí First Tool Enforcement (critical)
4. P1-3.3 ‚Üí Message Transform (session start)
5. P1-3.4 ‚Üí Post-Compact (compaction)
6. P1-3.6 ‚Üí Permission Auto-Deny (errors)
7. P1-3.7 ‚Üí Event Lifecycle (cleanup)

---

*Plan: 01-03 (Plugin Interception)*
*Phase: 01-contracts-first-governance-core*
*Created: 2026-02-03*
