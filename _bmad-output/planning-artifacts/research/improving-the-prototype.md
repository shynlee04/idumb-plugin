## 

pay attention to this time fix this:

- the init install must get users → to the selection of by-step guides; detection of their project including
    - the appending “concepts” of us → to global or project-based
    - the GSD framework https://github.com/glittercowboy/get-shit-done (again this is used as client-service at user’s project) → that what they are and how the wrappers tend to do
        - hierarchy and types of concepts (documents? governance? artifacts? and concepts? so on..)
        - when we wrap something into what it does → what the concepts changed etc
        - the absolute correct wrap non-breaking
    - there must be the scripts, tools as for configuration and settings

### Core concepts:

1. CLI tools of Plugin for OpenCode (later other) >> acting as wrappers other popular software development frameworks (starting with BMAD, Speckit and other spec-drive), GSD, through providing automatic and enhanced tools (agent’s tools, CLI tools and as scripts)  so that the frameworks are activated with these concepts:
    1. Intelligent Automation  and improve app development success rate by following  and even enhancing the wrapped frameworks’ guardrails and governance → that  make possible with the following 
        1. allowing multiple hierarchy auto governance and handoff artifacts between primary agents, agents and subagents → to intelligently decide by coordinator to run in parallel  or sequential >>>  
        2. keeping track and validate of guardrails concepts hierarchically and intelligently with supportive tools to transform guardrails and governance to hierarchy, meta tada and machine detectable >> validate, match, event watch, auto hooks and recovery backing >>> making sure all controlled governance entities are tracked and self-remediated 
    2. advanced context (the .idumb-brain) + boosting expertise, accuracy (preventing drift, hallucination, ready to confront human dev to prevent incompletion or bad practices) of agents:
        1. Advanced context : extensively and aggressively  treat context into these (as for improving the above mentioned)
            1. context classification: codebase, dev sessions, governance document and artifacts, workflows between agents >>> provide the correct tools use for search context, boost reasoning of agents  between con text
            2.  hierarchy + relationship: making context into >>> cognitive processor to agents  
            3. metadata, id, strict numbering, controlled with frontmatter and naming convention >>> making tracking of context easier
            4.  purging stale and drift context with the combination techniques + forced date and time stamps
        2. boosting expertise, accuracy >> agents act as experts that auto governance with domain-specific and providing user’s with experts viewpoints
            1. Intelligence boosting with “enforced thinking frameworks” → think of the framework that different types of agents vs. different tasks, phase of dev, types of project vs. complexity, greenfield or brownfield etc >>> these framing will be enforce into the above context, across types, making reasoning valid

## Revamp the concepts by putting deep thoughts into this (and the dos and donts)

1. For the appending agents https://opencode.ai/docs/agents/  (study the configuration very carefully) - to ensure hierarchy, and accuracy of when and where they got called and by which other agents (not only of the appended but to the wrapped agents as well); so look more into the hierarchy manipulation concepts (knowing there are up to 3 level of cycles of delegations, and settings that use to manipulate them are mode: primary, all and subagents - subagents can’t call any other agents; but agents set at all can delegate multi level, but if agents are particularly just for being delegated make them subagents. And to manipulate subagents not being called manually by users make them hidden which is only for delegation tasks)  and there should be these agents (high-level only you must think more to make them valid)
    1. supreme_coordinator (top highest)
    2. high-level-governance → doing the high and mid governance → they must be able to auto append prompts  and system prompts or initiate commands to force a workflow for instance ; these are also the way for them to adapt new profile
    3. low-level-validator: there are all sort validation work but these will directly do the grep, list, glob, seaarch and keyword regrex or run tools and run test kind of things
    4. idumb-builder: this will run tools, folllow appended prompt and commands, will spawn initially to wrap context to intended framework in yaml frontmatter (of course following the hierarchy) + also literately edit the appended concepts to match to certain conditions and the project >>> there must be a very meticulous design for this that match nested levels and relationship. And during phases this want must be updated too
2. commands and CLI commands → users will use these to initiate something - of course starting with init but not to make these overlapping with any others make sure they are all prefixed with `idumb` → as for these can be used by for the rest
- Forced  automation, forced hierarchy, relational, classification, auto purge impure context (stale, irrational, broken chained of id, series of numbering id into all aspects that these are wrapped to or as themselves >>> So to truly achieve just one sector you should be able to make whaever agents can succesfully do these:
    - Thinking in sequences, knowing which happened, by whom, which cycles etc → think above delegate cycles of context gathering to synthesize most accurate context kinds of thing
    - the manipulation of making TODO spawn every time but make them support 3-level hierarchy with hooks to conditional bounce back
    - to which we have force mechanism of which to do first then next then loops back (these are true for everythings, can markdown, yaml, xml, json manipulate this state of hop reading for instance
    - the long-term context also >>> how by using just grep, or any tools of use that can manipulate meta data, relational data to form neuro link >>> enable this kind of appended weekly, even monthly archive that allow these kinds of feature (and as these happens during the very intensive project done by multiple teams) >>> of coruse these take very robust and fine-tuning later but I just give example of one extreme case so you can imagine and to research to really answer if this is possible  → from the aspect of long-term brain, this complex project of the team when using idumb has append the very structural (that including meta data, synthesis of entities like user message, what happened, what agents, workflows, at which phase of the project, planning , id of them and so on) - but somehow the hook of idumb was not working as for purging poisoned broken context (as id metadata was ignored when broken) >>> now leaving just this exceeding windows context xml (or yaml or whatever format ) > let’s say by 500k of lines
        - swarm of agents can still grep, glob, think critically >>> (of course by multiple iterations ) to tell what went wrong, at which day, who did that, which plan, phases and what chage >>> sufficient 400 lines report condense and impactful accurately addressed
    1. I know most of what you are going to created can fail desperately but at least the testing concepts for this prototype must work

## Dos and Donts for the OpenCode Plugin and as Framework wrapper:

 

| Concepts | DO | DONTS | RESEARCH + THINK ABOUT |
| --- | --- | --- | --- |
| As a Plugin to instal by users |   • Understand all the concepts of what is a plugin in OpenCode 
  • Understanding the concepts of OpenCode using as client-side - when users use it as a platform to develop project
  • Do understand the core concepts or what drive OpenCode as a platform to developer using agentic coding: `commands`, `agents`, `subagents` , `innate tools` , `customized tools`, `rules`, `skills,`  , `sessions` , `lsp server`, `mcp server`
  • understand the 2-level of OpenCode platforms, global setting, and project
  •Understand extra concepts provided must click into either, both, or some of the above  |   • DON’T assume anything related to OpenCode concepts as in this development environment
  • DON’T misunderstanding to fall into :users using any core source code of OpenCode
  • DON’T be creative to create something that DO NOT work in OpenCOde | look for pages online for the official instructions - Think about users use the plugins by installing them from github page, npm, pnpm, npx command |
| As a plugin that provide wrappers |   • if providing any extra concepts → must align and point to the original framework in this case GSD
  • wrap the concepts into the framework with all the aware of the ecosystem, hierarchy, relationship, the flow, the governance of the intended framework |   • DON’T assume anything work if not making any connection points
  • DON’T assume it works if it does not reflect hierarchy, nor integration
  • DON’T assume it works if it has no governance
  • DON’T break any concepts (either core, short-live artifacts in any level of the intended frame-work) 
  •  |   • Learn the concepts |
| Working with users’ current project |   • DO understand the projects are varied, and that they are in multiple level of complexity and at any stage |   • DON’T assume users will do this nor the others if there are not guidance, not one place but throughout |  |
| Work across concepts, into hierarchy, activate automation, engaging in governance and validation activities of the framework and under OpenCode concepts  |   • Do understand as hierarchy as above but also  how they behave when wrapped
  • DO understand to activate automation, validation and self-governance >>> there must be a meticulous approach to multi-level and cross-concepts integration points  |   • DON’T assume that agent workflow get immediate constitute or obey to with just a rule in one place. Enforcement must not be scattered and unthoughtful
  • DON’T assume that what you introduce work → must ensure the agent of the project consume it at not only the start of the conversation but also pin it throughout |  |
|  |  |  |  |

## The definition of “IF IT WORKS” → if check on all concepts you have created and any do of them can not check all of the list that its belong to → they need improvement:

## PHASE 1 + PHASE 2 FEATURES (UNCHECKED) ___________________________________

→ Update with configuration that include what to call user, language ai to communicate with users, language of documents and artifacts (list of popular languages including english, vietnamese etc >>> the configuration will appended and be the first  read  at any session at all hierarchy → as it should also include direction to (hierarchically) these:

- paths to status and state control
    - context of__
        - hierarchy of context__
    - state of ___
        - hierarchy of state___
    
- paths to documents and artifacts of: same of above

and the enforcements and general guidelines  → currently as we are making GSD wrapper and as GSD has spawn their config.json (research for path) → our method must trace and append accurately

- and make sure all installation work with any os. Interactive or none must all show status when completion
- at for now interactive does not work

Add new features belong to governance, automation governance, and context intelligence that relate to controlled of code file structures → create new files and update update files watch → manifest watch to prevent drift, overlapping, conflicts → connect with atomic git hash control of GSD

- Feat 2: time and date stamp to frontmatter of short-live artifacts (thoese like plan, phase that generated by ai agents under GSD)  → these are meta data controlled  → these also registered to base the drift or conflict base on stale or conflict time and date

## PHASE 3 FEATURES (auto loop starting with research) → after of this phase 3 I will install the idumb to this and test with this:

1. manipulation of session creation/modification/export + modify and add more of the metadata, change name by having this made successful can extend to
    1. auto creation of new session → by highest coordinator → when main cycle of workflow completion → append upgraded context from last message of the agent +  hierarchy mindset + GSD wrapping mental  (check at which phase of GSD to append which command → to force gathering relevant context)
    2. if cycle of delegation run can also be manipulated → there would be me enhancement for the below
    3. with chunk reading tool + auto delegation to grep read session export + iterative sub agents launching → you can think about the long-term context creation as the brain I mentioned earlier
2. manipulation of TODO tasks list → can it be enforced as coordinator first thing to do, can it be make hierarchy and a longer list with metadata for coordinator and its coordinating games? ( 20+  and  insert brief context under each task ?) → research + to pair with stop hook (not allow stop when not updating TODO task) +  hook to this will append to session the hierarchy context of the workflow for example (to prevent context drift + to enforce validator)
    1. the above can be think of for enforcing validation + governance of completion task
    2. the above can be think of for enforcing no code touch without matching plan id

### The non-negotiable common list:

- [ ]  if the concepts were to modify OpenCode SourceCode to make it work → it wont because saying above (users  have OpenCode as a client-side platform → the plugin is in no way trying to fork Source Code from this perspective)
- [ ]  Read and understand very carefully the do and the don’ts above → form the matrix of list
- [ ]  For the concepts of idumb as they are features → they must resonate with the `Core concepts:` which are visions for idumb
- [ ]  Any configuration that are not definite (different and controlled by users which are not in anyway belong to either GSD nor OpenCode innate values ) >>> These are of the list that users can not have access to (like models of llm) and they will be block out of the concept >>>they must be removed out and if they are needed for the concepts work find work-around
- [ ]  they must all obey to the above donts and dos
- [ ]  anything contribute  to runtime starting (starting a session) → must be aligned to hierarchy and the automation to bounce back, loop, cycle and validation
- [ ]  if any introduced concepts contribute to the “mid-session-activity” either they contribute to the automation or appending relevant commands or prompts and those must be made sure to consume by LLMs and aiding with anchoring context in hierarchy and relational level and acting as reminders of constitution and governance (supporting with the knowing of cycles, loops and their hierarchy)
- [ ]  if they contribute to the “wrappers” of either OpenCode or GSD → they must make sure un-break regulation, accuracy, completion, consistent and meta data controlled (these are often those concepts that make edit to yaml fronmatter )
- [ ]  if anything related to yaml fronmatter, json configuration, api schema control → if they are to control OpenCode and that define by OpenCode API schema → they must all be accurate

## The “automation” group

- [ ]  if they belong to the group of scripts, hooks, customized tools, and/or manipulations/modification of the OpenCode core >>> read their API do not mistaken with “forking” the source code - those do not work ; these group need extra attention to “not-break-things” → this group also must be careful for fallback strategy as they do not all times executed correctly
- [ ]  if the automation concepts depends on prompts, commands and LLMS read → make sure to meticulously prompt with context help with clear requirements, acceptance criteria, meta data matching and check list (However do not over enegineer this as it may consume context exceeding the models)

### The status group and the core governance documents (either wrapper, self-added) must all

- [ ]  They are made by agent of the client’s project → iterated (throughout not append), one version and stale check, id with meta data (regulated), detection of conflicts and stale
- [ ]  for foreseeable these types of documents or artifacts that may get long >>> come up with tools, script that activate chunk sequential chunk reading → validating, and appending content in chunk (but still gain exact accuracy)

### The “delegations” and multi-cycle

- [ ]  all highest level (agents, coordinator) must all be controlled with enforce context-first, frameing with master tracking and hierarchy todo → must delegate and ban all execution
- [ ]  the mid-level delegation can be depend on which phases → but modifying code file (creating code files) should never be the permissions

### `Core concepts` :  only these made success - concepts work

- [ ]  starting points → integration multiple levels - integration to OpenCode and GSD → not making any overlapping or conflict concepts + not breaking any chain + not breaking core OpenCode nor GSD
- [ ]  Have you address edge cases of what if from users using GSD - to validate cases against user’s journey
- [ ]  Have you assess issues both high-level (as a strategist) and mid to low level tactically

## Making it into its own framework

as many attempts of iterations on trials and errors but could not bring out the finest results when playing the wrapper approach (because the level of precision and control over the targeted GSD frameworks, and your high-level of hallucination when having to mange too many things) >>> my decisions to  make shift to a complete meta framework (still hold true to all above value) >>> ONLY NOW THAT WE WILL TAKE OVER WHAT GSD FRAMEWORK IS DOING AND make them even betters by not only fine-tuning the templates (concepts of using commands, prompts, agents, subagents ); improve with more controlled accuracy with more concepts like SKILL and customized tools and hooks manipulation;  and make of interpretation of  “Self-intelligent-governance” “Expert-agent-first” and “Context-first” with absolute validation and guardrails: >>> So the below need u to start the project and store these into more valid and hierarchy set so that we can start phases after phases with more granular and controlled

## The research

Beside these research sofar

```markdown
CROSS-CONCEPT-MATRIX-2026-02-02.md
event-subscription-opencode.md
grep-carefully-to-really-learn-what-happen-.md
IMPLEMENTATION-GUIDE.md
INTERCEPTION-ARCHITECTURE-ANALYSIS.md
INTERCEPTION-SOLUTION-SUMMARY.md
VALIDATION-CHECKLIST-2026-02-02.md
```

- I need the following system of research so that you can

1. learn carefully how the GSD concepts implement each other; their concepts; their control over different entry points of a project through OpenCode concepts and through themselves as a framework >>>> then validate with this if this is still true CROSS-CONCEPT-MATRIX-2026-02-02.md
2. Then “Through some other concepts being learnt from OpenCode and some other Community plugins (Do not copy exactly but improve them)  of that you learn from to synthesize a more complete picture >>> you can follow the below guide 

### **Phase 2.1 `Less for more`**  <<>> OpenCode Concepts of: its native tools; agents (primary, all, and subagents); Agent SKILLS; Commands, permissions >>> Update on Skill This is not very true the Skill should come only as support to trigger them automatically is probable

the `less for more` means these: consume only what needs and valid; agents automatically know by drilling down to the assigned hierarchy, making used of “loaded-on-demand” and improve accuracy by “allowing specific prompts being used when of which agents” - in the group we have SKILLS are the most popular known for this less for more. Beside more is because these granular controls give us more matches, fine-tuning the per-case uses without compromising much context windows

- list of native tools https://opencode.ai/docs/tools/ → pair with `permissions` for →
- agents https://opencode.ai/docs/agents/   → agents can setup into `modes` (keywords: all, primary, subagent, permission.tasks, permissions, prompts, hidden - the focus can create more granular configuration for all our roles, high-level, lower-level coordinator, enforce on what tools use etc →
    - → pair with `commands` to invoke agents https://opencode.ai/docs/commands/
    - → or even make permissions more granular controls https://opencode.ai/docs/permissions/
- the trump card of this `less for more  https://github.com/zenobi-us/opencode-skillful?tab=readme-ov-file`→ read this very carefully as they pari quite well with almost everything up therehttps://github.com/zenobi-us/opencode-skillful?tab=readme-ov-file >>> SINCE WE CAN FORCE USER INSTALL ANY MORE OF SO THIS IS SHOULD BE MADE NATIVE IN OUR PLUGIN

---

### **Phase 2.2  `accurately specific with concision`**  <<>> OpenCode Concepts of: custom tools , Agent SKILLS; agents (primary, all, and subagents); overwritten innate commands

this is the methodology for making use of `metadata` `frontmatter` ; or making a combo of tools executions in certain order as `context` is observed and/or pair with our dev `scripts` in package.json for auto-run quick automation of validation tools → make controlling much less token but specifically accurate 

- Custom tools https://opencode.ai/docs/custom-tools/ (keywords: multi tools per files, context → as a tools so what tools can pair with this can too
- overwritten commands: same as commands above but focus more on keywords built-in, sub-tasks, file references → yes with custom tools and per agent manipulate the `compact` command that summarized and reference specific types of artifacts, and of metadata and controlled with frontmatter
- ok with Agent SKILLS → improve specificity and accuracy in a much higher level
- 

---

### **Phase 2.3  `the best governance = auto, routined, and eventwatch`**  <<>> this include just this one https://opencode.ai/docs/plugins/

this is a hand-down overkill → because it include almost all-in-one-and-the-beyond-mixture-of-whatever-order sets of everything else >>> YES AND THIS IS US WE ARE MAKING A PLUGIN TO BECOME A ALL-IN-ON-PACK

## SOME OTHER PLUGINS OF COMMUNITY TO LEARN FROM

Here’s an index of the OpenCode ecosystem **plugins** listed on that page, with one‑line descriptions: (there are those with TODO tasks and subtasks or anything that you feel click with our approach you can learn from to synthesize later)

- opencode-daytona – Run OpenCode sessions in isolated Daytona sandboxes with git sync and live previews.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-helicone-session – Inject Helicone session headers automatically for request grouping.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-type-inject – Auto-inject TypeScript/Svelte types into file reads via lookup tools.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-openai-codex-auth – Use a ChatGPT Plus/Pro subscription instead of OpenAI API credits.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-gemini-auth – Use an existing Gemini plan instead of API billing.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-antigravity-auth – Use Antigravity’s free models instead of API billing.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-devcontainers – Multi-branch devcontainer isolation with shallow clones and auto-assigned ports.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-google-antigravity-auth – Google Antigravity OAuth plugin with Google Search support and robust API handling.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-dynamic-context-pruning – Prune obsolete tool outputs to optimize token usage.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-websearch-cited – Add native websearch with Google-grounded-style citations for supported providers.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-pty – Let agents run background PTY processes and send interactive input.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-shell-strategy – Guidance for non-interactive shell commands to avoid TTY-dependent hangs.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-wakatime – Track OpenCode usage with Wakatime.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-md-table-formatter – Clean up markdown tables generated by LLMs.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-morph-fast-apply – Faster code editing via Morph Fast Apply API and lazy edit markers.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- oh-my-opencode – Background agents, curated agents, and pre-built LSP/AST/MCP tools, Claude Code compatible.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-notificator – Desktop notifications and sound alerts for OpenCode sessions.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-notifier – Desktop notifications and alerts for permissions, completions, and error events.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-zellij-namer – AI-powered automatic naming of Zellij sessions from OpenCode context.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-skillful – Lazy-load prompts with skill discovery and injection for agents.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-supermemory – Persistent cross-session memory using Supermemory.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- @plannotator/opencode – Interactive plan review with visual annotation and private/offline sharing.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- @openspoon/subtask2 – Extend /commands into an orchestration system with granular flow control.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-scheduler – Schedule recurring jobs via launchd/systemd using cron syntax.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- micode – Structured Brainstorm → Plan → Implement flow with session continuity.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- octto – Interactive browser UI for AI brainstorming with multi-question forms.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-background-agents – Background agents with async delegation and context persistence.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-notify – Native OS notifications so you know when tasks complete.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-workspace – Bundled multi-agent orchestration harness with many components in one install.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]
- opencode-worktree – Zero-friction git worktrees for OpenCode.[[opencode](https://opencode.ai/docs/ecosystem#plugins)]

## The most important things that you should never be drift out of

- this is a plugin meaning users of all walks can install it with npx, pnpm, npm, bunx from my github setting at public >> so these assumption SHOULD NEVER be made to any of the list
    - assume users’ llm models
    - making this project .opencode folder’s files changes
    - marking changes to OpenCode source code (as forking) X Not allow because users use it OpenCode as client
    - assume a project as greenfield >>> NO  THEY ARE MUCH MANY MORE ENTRY POINTS
    - assume they will install this as project-base level >>> NOT, they can install this at global settings level too

## The ready-to-use or ideas that facilitate the following:

Because the concepts of “highly-intelligent”, “self-governance” , “context-supreme”; multi-iterative-loop of highly accurately project development frame work so these tools, combination of any sdk, packages that may help with the following (but make sure they are make into these categories: run on client-side environment, is package with our plugin and work under the same Concepts of us and OpenCode, nay “brain concepts” of having to make use of database >>> they must be light, fast, and run at their local under subfolder of our brain concept>>> all these to allow OpenCode LLM as agents execute, retrieve, use, modify and read right at local dev environment

- Build-in brain Concept  >>> this require a lot from these group
- tools supporting fast searching + hop-reading across not only sections of a files, but also across paths both horizontal and vertical (innate with grep, glob, list, regex would not enough ) >>> I need your insights in this
- tools that allow accurate chunk writing + controlled metadata and more through schema and api  + parsing and shard tools  into json the relational of values, id, properties of sorts >>> these ideas are for creating long-term traceable nodes and relational data for the ideas of brainy agents → must understand layers, hierarchy, from conversation, to controlled workflows and loops, using time and date and id system into schema to control drift and gaps
    - >>> yes the above can be made with AI agent by transforming data but they LLM can’t be accurately follow a set if not using tools. I mean they are fine with writing recap, or synthesize description but metadata and schema needs control through manipulation subscription to LSP at OpenCode for instance https://opencode.ai/docs/lsp/
- that’s same thing for AST indexing of the codebase combining with subscription to event watch of file changes, file update + meta data and relational nodes >>> to give more powerful approach toward symbol level reading of agents to the codebase

— Reseach up-to-date to 2026 tech